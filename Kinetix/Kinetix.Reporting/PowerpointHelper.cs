using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using DocumentFormat.OpenXml;
using DocumentFormat.OpenXml.Packaging;
using DocumentFormat.OpenXml.Presentation;
using D = DocumentFormat.OpenXml.Drawing;
using D10 = DocumentFormat.OpenXml.Office2010.Drawing;
using System.Text.RegularExpressions;
using DocumentFormat.OpenXml.Validation;

namespace Kinetix.Reporting {
    /// <summary>
    /// Class which goal is to contain all the functions you need to manipulate Powerpoint files.
    /// </summary>
    public static class PowerpointHelper {

        /// <summary>
        /// Variable serving only for id distribution. Cf GetNextId().
        /// </summary>
        private static uint incrementor = 0;

        /// <summary>
        /// Regular expression to match for all color codes.
        /// </summary>
        private static Regex hexaColorRegex = new Regex("[a-fA-F0-9]{6}$");

        private static readonly OpenXmlValidator validator = new OpenXmlValidator();
            
        /// <summary>
        /// As a powerpoint presentation behave better if all objects have a different id, this function provides those unique ids.
        /// </summary>
        /// <returns>An unused integer.</returns>
        private static uint GetNextId() {
            return ++incrementor;
        }

        /// <summary>
        /// Create a powerpoint presentation with one slide and needed configuration parts and parameters.
        /// You should then use GetShapeTreeOfFirstSlide() to get started.
        /// </summary>
        /// <param name="fileName">Full path of the presentation file.</param>
        /// <param name="slideWidth">Width of the slide in EMU. Default: default width of a new slide in Powerpoint. It should be positive.</param>
        /// <param name="slideHeight">Height of the slide in EMU. Default: default height of a new slide in Powerpoint. It should be positive.</param>
        /// <returns>The new presentation.</returns>
        public static PresentationDocument CreatePresentationWithOneEmptySlide(string fileName, int slideWidth = 9144000, int slideHeight = 6858000) {
            if (fileName == null) throw new ArgumentNullException("fileName");
            if (slideWidth < 914440) throw new ArgumentOutOfRangeException("slideWidth", slideWidth, "slideWidth should be greater than 914440.");
            if (slideHeight < 914440) throw new ArgumentOutOfRangeException("slideHeight", slideHeight, "slideHeight should be greater than 914440.");

            PresentationDocument presentationDoc = PresentationDocument.Create(fileName, PresentationDocumentType.Presentation);
            PresentationPart presentationPart = presentationDoc.AddPresentationPart();
            presentationPart.Presentation = new Presentation();

            CreatePresentationParts(presentationPart, slideWidth, slideHeight);

            var errors = validator.Validate(presentationDoc);
            if (errors.Count() > 0) throw new ApplicationException("Invalid Xml presentation generated by CreatePresentationWithOneEmptySlide.");
            return presentationDoc;
        }

        /// <summary>
        /// Get the shape tree of the first slide of the presentation.
        /// The shape tree is where all elements must be added: images, texts, shapes, groupShapes...
        /// </summary>
        /// <param name="presentationDocument">Presentation containing the wanted shape tree.</param>
        /// <returns>The shape tree.</returns>
        public static ShapeTree GetShapeTreeOfFirstSlide(PresentationDocument presentationDocument) {
            SlidePart slidePart = GetFirstSlidePart(presentationDocument);
            Slide slide = slidePart.Slide;
            ShapeTree shapeTree = slide.CommonSlideData.ShapeTree;

            var errors = validator.Validate(shapeTree);
            if (errors.Count() > 0) throw new ApplicationException("Invalid Xml presentation generated by GetShapeTreeOfFirstSlide.");
            return shapeTree;
        }

        /// <summary>
        /// Add an OpenXmlElement to another one. It can be used to add a Shape to a ShapeTree or a GroupShape for exemple.
        /// </summary>
        /// <param name="parent">The parent element.</param>
        /// <param name="child">The child element.</param>
        public static void AddElement(OpenXmlElement parent, OpenXmlElement child) {
            parent.Append(child);
        }

        /// <summary>
        /// Add an image to an OpenXmlElement.
        /// This function puts the image in slide's resources, and add a reference to this image in the openXmlElement.
        /// </summary>
        /// <param name="parent">The element in which the image should be contained.</param>
        /// <param name="logoPath">Full path of the image.</param>
        /// <param name="left">X coordinate of the image in EMU.</param>
        /// <param name="top">Y coordinate of the image in EMU.</param>
        /// <param name="width">Width of the image in EMU. It should be positive.</param>
        /// <param name="height">Height of the image in EMU. It should be positive.</param>
        public static void AddImage(OpenXmlElement parent, string logoPath, int left, int top, int width, int height) {
            if (logoPath == null) throw new ArgumentNullException("logoPath");
            using (Stream stream = new FileStream(logoPath, FileMode.Open)) {
                AddImage(parent, stream, left, top, width, height);
            }
        }
        
        /// <summary>
        /// Add an image to an OpenXmlElement.
        /// This function puts the image in slide's resources, and add a reference to this image in the openXmlElement.
        /// </summary>
        /// <param name="parent">The element in which the image should be contained.</param>
        /// <param name="logoStream">File stream of the image.</param>
        /// <param name="left">X coordinate of the image in EMU.</param>
        /// <param name="top">Y coordinate of the image in EMU.</param>
        /// <param name="width">Width of the image in EMU. It should be positive.</param>
        /// <param name="height">Height of the image in EMU. It should be positive.</param>
        public static void AddImage(OpenXmlElement parent, Stream logoStream, int left, int top, int width, int height) {
            if (logoStream == null) throw new ArgumentNullException("logoStream");
            if (width < 0) throw new ArgumentOutOfRangeException("width", width, "width should be positive.");
            if (height < 0) throw new ArgumentOutOfRangeException("height", height, "height should be positive.");
            Slide slide = parent.Ancestors<Slide>().SingleOrDefault();
            if (slide == null) throw new ArgumentException("The provided parent element should be in a slide. Did you forget an AddElement()?", "parent");
            SlidePart slidePart = slide.SlidePart;
            ImagePart imagePart = slidePart.AddImagePart(ImagePartType.Png);

            imagePart.FeedData(logoStream);

            string imageId = slidePart.GetIdOfPart(imagePart);

            Picture picture1 = new Picture();

            uint id = GetNextId();
            string typeName = "Picture";
            NonVisualPictureProperties nonVisualPictureProperties1 = new NonVisualPictureProperties();
            NonVisualDrawingProperties nonVisualDrawingProperties1 = new NonVisualDrawingProperties() { Id = id, Name = typeName + id };

            NonVisualPictureDrawingProperties nonVisualPictureDrawingProperties1 = new NonVisualPictureDrawingProperties();
            D.PictureLocks pictureLocks1 = new D.PictureLocks();

            nonVisualPictureDrawingProperties1.Append(pictureLocks1);
            ApplicationNonVisualDrawingProperties applicationNonVisualDrawingProperties1 = new ApplicationNonVisualDrawingProperties();

            nonVisualPictureProperties1.Append(nonVisualDrawingProperties1);
            nonVisualPictureProperties1.Append(nonVisualPictureDrawingProperties1);
            nonVisualPictureProperties1.Append(applicationNonVisualDrawingProperties1);

            BlipFill blipFill1 = new BlipFill();

            D.Blip blip1 = new D.Blip() { Embed = imageId, CompressionState = D.BlipCompressionValues.Print };

            D.BlipExtensionList blipExtensionList1 = new D.BlipExtensionList();

            D.BlipExtension blipExtension1 = new D.BlipExtension() { Uri = "{28A0092B-C50C-407E-A947-70E740481C1C}" };

            D10.UseLocalDpi useLocalDpi1 = new D10.UseLocalDpi() { Val = false };
            useLocalDpi1.AddNamespaceDeclaration("a14", "http://schemas.microsoft.com/office/drawing/2010/main");

            blipExtension1.Append(useLocalDpi1);

            blipExtensionList1.Append(blipExtension1);

            blip1.Append(blipExtensionList1);

            D.Stretch stretch1 = new D.Stretch();
            D.FillRectangle fillRectangle1 = new D.FillRectangle();

            stretch1.Append(fillRectangle1);

            blipFill1.Append(blip1);
            blipFill1.Append(stretch1);

            ShapeProperties shapeProperties1 = new ShapeProperties();

            D.Transform2D transform2D1 = new D.Transform2D();
            D.Offset offset1 = new D.Offset() { X = left, Y = top };
            D.Extents extents1 = new D.Extents() { Cx = width, Cy = height };

            transform2D1.Append(offset1);
            transform2D1.Append(extents1);

            D.PresetGeometry presetGeometry1 = new D.PresetGeometry() { Preset = D.ShapeTypeValues.Rectangle };
            D.AdjustValueList adjustValueList1 = new D.AdjustValueList();

            presetGeometry1.Append(adjustValueList1);

            shapeProperties1.Append(transform2D1);
            shapeProperties1.Append(presetGeometry1);

            picture1.Append(nonVisualPictureProperties1);
            picture1.Append(blipFill1);
            picture1.Append(shapeProperties1);

            parent.Append(picture1);
            
            var errors = validator.Validate(slide);
            if (errors.Count() > 0) throw new ApplicationException("Invalid Xml presentation generated by AddImage.");
        }

        /// <summary>
        /// Create a polygon from a list of points.
        /// </summary>
        /// <param name="list">List of points [x,y] of the polygon.</param>
        /// <param name="colorCode">RGB hexadecimal filling color code. Default: null. Format: RRGGBB.
        /// If null, the polygon is not filled.</param>
        /// <returns>The new polygon.</returns>
        public static Shape CreatePolygon(List<int[]> list, string colorCode = null) {
            if (list.Count <= 0) throw new ArgumentException("list should contain at least one element.", "list");
            foreach (int[] point in list) {
                if (point.Length != 2) throw new ArgumentException("list should be a list of array of length 2.", "list");
            }
            CheckHexaColorCode(colorCode);

            int[] extremumCoordinates = GetExtremumCoordinate(list);

            Shape shape1 = new Shape();

            uint id = GetNextId();
            string typeName = "Polygon";
            NonVisualShapeProperties nonVisualShapeProperties1 = CreateNonVisualShapeProperties(id, typeName);

            ShapeProperties shapeProperties1 = new ShapeProperties();

            D.Transform2D transform2D1 = new D.Transform2D();
            D.Offset offset1 = new D.Offset() { X = extremumCoordinates[0], Y = extremumCoordinates[2] };
            D.Extents extents1 = new D.Extents() { Cx = extremumCoordinates[1] - extremumCoordinates[0], Cy = extremumCoordinates[3] - extremumCoordinates[2] };

            transform2D1.Append(offset1);
            transform2D1.Append(extents1);

            D.CustomGeometry customGeometry1 = new D.CustomGeometry();
            D.AdjustValueList adjustValueList1 = new D.AdjustValueList();
            D.ShapeGuideList shapeGuideList1 = new D.ShapeGuideList();
            D.AdjustHandleList adjustHandleList1 = new D.AdjustHandleList();
            D.ConnectionSiteList connectionSiteList1 = new D.ConnectionSiteList();
            D.PathList pathList1 = new D.PathList();
            D.Rectangle rectangle1 = new D.Rectangle() { Left = "l", Top = "t", Right = "r", Bottom = "b" };
            D.Path path1 = new D.Path() { Width = extremumCoordinates[1] - extremumCoordinates[0], Height = extremumCoordinates[3] - extremumCoordinates[2] };


            for (int i = 0; i < list.Count; i++) {
                var tempArray = list[i];
                int[] array = { tempArray[0] - extremumCoordinates[0], tempArray[1] - extremumCoordinates[2] };
                D.ShapeGuide shapeGuide1 = new D.ShapeGuide() { Name = String.Format("connsiteX{0}", i), Formula = String.Format("*/ {0} w {1}", array[0], extremumCoordinates[1] - extremumCoordinates[0]) };
                D.ShapeGuide shapeGuide2 = new D.ShapeGuide() { Name = String.Format("connsiteY{0}", i), Formula = String.Format("*/ {0} h {1}", array[1], extremumCoordinates[3] - extremumCoordinates[2]) };
                shapeGuideList1.Append(shapeGuide1);
                shapeGuideList1.Append(shapeGuide2);


                D.ConnectionSite connectionSite1 = new D.ConnectionSite() { Angle = "0" };
                D.Position position1 = new D.Position() { X = String.Format("connsiteX{0}", i), Y = String.Format("connsiteY{0}", i) };
                connectionSite1.Append(position1);
                connectionSiteList1.Append(connectionSite1);

                D.Point point = new D.Point() { X = (array[0]).ToString(), Y = (array[1]).ToString() };

                if (i == 0) {
                    D.MoveTo moveTo1 = new D.MoveTo();
                    moveTo1.Append(point);
                    path1.Append(moveTo1);
                } else {
                    D.LineTo lineTo1 = new D.LineTo();
                    lineTo1.Append(point);
                    path1.Append(lineTo1);
                }
            }

            path1.Append(new D.CloseShapePath());

            pathList1.Append(path1);

            customGeometry1.Append(adjustValueList1);
            customGeometry1.Append(shapeGuideList1);
            customGeometry1.Append(adjustHandleList1);
            customGeometry1.Append(connectionSiteList1);
            customGeometry1.Append(rectangle1);
            customGeometry1.Append(pathList1);


            shapeProperties1.Append(transform2D1);
            shapeProperties1.Append(customGeometry1);

            if (String.IsNullOrEmpty(colorCode)) {
                shapeProperties1.Append(new D.NoFill());
            } else {
                D.RgbColorModelHex rgbColorModelHex1 = new D.RgbColorModelHex() { Val = colorCode };
                D.SolidFill solidFill = new D.SolidFill();
                solidFill.Append(rgbColorModelHex1);
                shapeProperties1.Append(solidFill);
            }

            D.Outline outLine = new D.Outline() { Width = 0 };
            D.RgbColorModelHex rgbColorModelHex2 = new D.RgbColorModelHex() { Val = "AAAAAA" };
            D.SolidFill solidFill2 = new D.SolidFill();
            solidFill2.Append(rgbColorModelHex2);
            outLine.Append(solidFill2);

            shapeProperties1.Append(outLine);

            TextBody textBody1 = new TextBody();
            D.BodyProperties bodyProperties1 = new D.BodyProperties() { RightToLeftColumns = false, Anchor = D.TextAnchoringTypeValues.Center };
            D.ListStyle listStyle1 = new D.ListStyle();

            D.Paragraph paragraph1 = new D.Paragraph();
            D.ParagraphProperties paragraphProperties1 = new D.ParagraphProperties() { Alignment = D.TextAlignmentTypeValues.Center };
            D.EndParagraphRunProperties endParagraphRunProperties1 = new D.EndParagraphRunProperties() { Language = "fr-FR" };

            paragraph1.Append(paragraphProperties1);
            paragraph1.Append(endParagraphRunProperties1);

            textBody1.Append(bodyProperties1);
            textBody1.Append(listStyle1);
            textBody1.Append(paragraph1);

            shape1.Append(nonVisualShapeProperties1);
            shape1.Append(shapeProperties1);
            shape1.Append(textBody1);

            var errors = validator.Validate(shape1);
            if (errors.Count() > 0) throw new ApplicationException("Invalid Xml presentation generated by CreatePolygon.");
            return shape1;

        }

        /// <summary>
        /// Create a rectangle. As a rectangle must have a Paragraph, be sure to add one.
        /// </summary>
        /// <param name="left">X coordinate of the rectangle in EMU.</param>
        /// <param name="top">Y coordinate of the rectangle in EMU.</param>
        /// <param name="width">Width of the rectangle in EMU. It should be positive.</param>
        /// <param name="height">Height of the rectangle in EMU. It should be positive.</param>
        /// <param name="fillColorCode">RGB hexadecimal filling color code. Default: null. Format: RRGGBB.
        /// If null, the polygon is not filled.</param>
        /// <param name="anchor">Vertical anchor of rectangle's text. Default: Top.</param>
        /// <param name="wrap">Wrapping method of rectangle's text. Default: Square.
        /// If you want the text to not wrap, set wrap to None.</param>
        /// <returns>The new rectangle.</returns>
        public static Shape CreateRectangleShape(int left, int top, int width, int height, string fillColorCode = null, D.TextAnchoringTypeValues anchor = D.TextAnchoringTypeValues.Top, D.TextWrappingValues wrap = D.TextWrappingValues.Square) {
            if (width < 0) throw new ArgumentOutOfRangeException("width", width, "width should be positive.");
            if (height < 0) throw new ArgumentOutOfRangeException("height", height, "height should be positive.");
            CheckHexaColorCode(fillColorCode); 
            
            Shape shape1 = new Shape();

            uint id = GetNextId();
            string typeName = "Rectangle";
            NonVisualShapeProperties nonVisualShapeProperties1 = CreateNonVisualShapeProperties(id, typeName);

            ShapeProperties shapeProperties1 = new ShapeProperties();

            D.Transform2D transform2D1 = new D.Transform2D();
            D.Offset offset1 = new D.Offset() { X = left, Y = top };
            D.Extents extents1 = new D.Extents() { Cx = width, Cy = height };

            transform2D1.Append(offset1);
            transform2D1.Append(extents1);

            D.PresetGeometry presetGeometry1 = new D.PresetGeometry() { Preset = D.ShapeTypeValues.Rectangle };
            D.AdjustValueList adjustValueList1 = new D.AdjustValueList();

            presetGeometry1.Append(adjustValueList1);

            shapeProperties1.Append(transform2D1);
            shapeProperties1.Append(presetGeometry1);

            if (String.IsNullOrEmpty(fillColorCode)) {
                shapeProperties1.Append(new D.NoFill());
            } else {
                D.RgbColorModelHex rgbColorModelHex1 = new D.RgbColorModelHex() { Val = fillColorCode };
                D.SolidFill solidFill = new D.SolidFill();
                solidFill.Append(rgbColorModelHex1);
                shapeProperties1.Append(solidFill);
            }

            shape1.Append(nonVisualShapeProperties1);
            shape1.Append(shapeProperties1);

            //Assume that a border is useful if and only if there is a background color.
            if (!string.IsNullOrEmpty(fillColorCode)) {
                ShapeStyle shapeStyle1 = new ShapeStyle();
                D.LineReference lineReference1 = new D.LineReference() { Index = (UInt32Value)2U };

                D.SchemeColor schemeColor1 = new D.SchemeColor() { Val = D.SchemeColorValues.Accent1 };
                D.Shade shade1 = new D.Shade() { Val = 50000 };

                schemeColor1.Append(shade1);

                lineReference1.Append(schemeColor1);

                D.FillReference fillReference1 = new D.FillReference() { Index = (UInt32Value)1U };
                D.SchemeColor schemeColor2 = new D.SchemeColor() { Val = D.SchemeColorValues.Accent1 };

                fillReference1.Append(schemeColor2);

                D.EffectReference effectReference1 = new D.EffectReference() { Index = (UInt32Value)0U };
                D.SchemeColor schemeColor3 = new D.SchemeColor() { Val = D.SchemeColorValues.Accent1 };

                effectReference1.Append(schemeColor3);

                D.FontReference fontReference1 = new D.FontReference() { Index = D.FontCollectionIndexValues.Minor };
                D.SchemeColor schemeColor4 = new D.SchemeColor() { Val = D.SchemeColorValues.Light1 };

                fontReference1.Append(schemeColor4);

                shapeStyle1.Append(lineReference1);
                shapeStyle1.Append(fillReference1);
                shapeStyle1.Append(effectReference1);
                shapeStyle1.Append(fontReference1);

                shape1.Append(shapeStyle1);
            }

            TextBody textBody1 = new TextBody();
            D.BodyProperties bodyProperties1 = new D.BodyProperties() { Anchor = anchor, Wrap = wrap, LeftInset = 0, TopInset = 0, RightInset = 0, BottomInset = 0, RightToLeftColumns = false };
            D.ListStyle listStyle1 = new D.ListStyle();

            textBody1.Append(bodyProperties1);
            textBody1.Append(listStyle1);

            shape1.Append(textBody1);
            
            return shape1;
        }

        /// <summary>
        /// Create and add a centered paragraph to the given shape.
        /// Similar to AddParagraph(..., Center);
        /// </summary>
        /// <param name="shape">The shape to which add a paragraph.</param>
        /// <param name="text">The text of your paragraph.</param>
        /// <param name="fontSize">Font size of the text. Default: 800. A 100x factor is applied to Powerpoint font size values.</param>
        /// <param name="fontColorCode">RGB hexadecimal font color code. Default: 212121. Format: RRGGBB.</param>
        /// <param name="bold">Should the text be bold? Default: false.</param>
        /// <returns>The new centered paragraph.</returns>
        public static D.Paragraph AddCenteredParagraph(Shape shape, string text, int fontSize = 800, string fontColorCode = "212121", bool bold = false) {
            return AddParagraph(shape, text, fontSize, fontColorCode, bold, D.TextAlignmentTypeValues.Center);
        }

        /// <summary>
        /// Create and add a paragraph to the given shape. A paragraph is a text container.
        /// The simplest way to add a text to a slide is to add a non filled rectangle first, and then add a paragraph to it.
        /// The shape should have a textBody.
        /// </summary>
        /// <param name="shape">The shape to which add a paragraph.</param>
        /// <param name="text">The text of your paragraph.</param>
        /// <param name="fontSize">Font size of the text. Default: 800. A 100x factor is applied to Powerpoint font size values.</param>
        /// <param name="fontColorCode">RGB hexadecimal font color code. Default: 212121. Format: RRGGBB.</param>
        /// <param name="bold">Should the text be bold? Default: false.</param>
        /// <param name="align">Text horizontal alignement. Default: Left.</param>
        /// <returns>The new paragraph.</returns>
        public static D.Paragraph AddParagraph(Shape shape, string text, int fontSize = 800, string fontColorCode = "212121", bool bold = false, D.TextAlignmentTypeValues align = D.TextAlignmentTypeValues.Left) {
            if (fontSize <= 0) throw new ArgumentOutOfRangeException("fontSize", fontSize, "fontSize should be positive.");
            CheckHexaColorCode(fontColorCode);

            D.Paragraph paragraph0 = new D.Paragraph();
            D.ParagraphProperties paragraphProperties0 = new D.ParagraphProperties() { Alignment = align };
            paragraph0.Append(paragraphProperties0);

            D.Run run0 = new D.Run();

            D.RunProperties runProperties0 = new D.RunProperties() { Language = "en-US", FontSize = fontSize, Bold = bold };

            D.SolidFill solidFill0 = new D.SolidFill();
            D.RgbColorModelHex rgbColorModelHex0 = new D.RgbColorModelHex() { Val = fontColorCode };

            solidFill0.Append(rgbColorModelHex0);

            runProperties0.Append(solidFill0);
            D.Text text0 = new D.Text();
            text0.Text = text;

            run0.Append(runProperties0);
            run0.Append(text0);

            paragraph0.Append(run0);
            AddElement(shape.TextBody, paragraph0);

            var errors = validator.Validate(paragraph0);
            if (errors.Count() > 0) throw new ApplicationException("Invalid Xml presentation generated by AddParagraph.");
            return paragraph0;
        }

        /// <summary>
        /// Create and add a textrun to a paragraph. A text run is a simple piece of text.
        /// Imagine it as a selection that you can copy/paste or change its font properties.
        /// </summary>
        /// <param name="paragraph">The paragraph to which add a textrun.</param>
        /// <param name="text">The text of your paragraph.</param>
        /// <param name="fontSize">Font size of the text. Default: 800. A 100x factor is applied to Powerpoint font size values.</param>
        /// <param name="fontColorCode">RGB hexadecimal font color code. Default: 212121. Format: RRGGBB.</param>
        /// <param name="bold">Should the text be bold? Default: false.</param>
        public static void AddTextRun(D.Paragraph paragraph, string text, int fontSize = 800, string fontColorCode = "212121", bool bold = false) {
            if (fontSize <= 0) throw new ArgumentOutOfRangeException("fontSize", fontSize, "fontSize should be positive.");
            CheckHexaColorCode(fontColorCode);
            
            D.Run run2 = new D.Run();

            D.RunProperties runProperties2 = new D.RunProperties() { Language = "en-US", FontSize = fontSize, Bold = bold };

            D.SolidFill solidFill4 = new D.SolidFill();
            D.RgbColorModelHex rgbColorModelHex4 = new D.RgbColorModelHex() { Val = fontColorCode };

            solidFill4.Append(rgbColorModelHex4);

            runProperties2.Append(solidFill4);
            D.Text text2 = new D.Text();
            text2.Text = text;

            run2.Append(runProperties2);
            run2.Append(text2);
            AddElement(paragraph, run2);
            var errors = validator.Validate(paragraph);
            if (errors.Count() > 0) throw new ApplicationException("Invalid Xml presentation generated by AddTextRun.");
            
        }

        /// <summary>
        /// Create a group shape. A group shape is an invisible shape that can contain many shapes.
        /// It is useful if you want some shapes to stick together.
        /// </summary>
        /// <param name="left">X coordinate of the group shape in EMU.</param>
        /// <param name="top">Y coordinate of the group shape in EMU.</param>
        /// <param name="width">Width of the group shape in EMU. It should be positive.</param>
        /// <param name="height">Height of the group shape in EMU. It should be positive.</param>
        /// <returns>the new group shape.</returns>
        public static GroupShape CreateGroupShape(int left, int top, int width, int height) {
            if (width < 0) throw new ArgumentOutOfRangeException("width", width, "width should be positive.");
            if (height < 0) throw new ArgumentOutOfRangeException("height", height, "height should be positive.");
            
            GroupShape groupShape1 = new GroupShape();

            uint id = GetNextId();
            string name = "Group";

            NonVisualGroupShapeProperties nonVisualGroupShapeProperties1 = new NonVisualGroupShapeProperties();
            NonVisualDrawingProperties nonVisualDrawingProperties1 = new NonVisualDrawingProperties() { Id = id, Name = name + id };
            NonVisualGroupShapeDrawingProperties nonVisualGroupShapeDrawingProperties1 = new NonVisualGroupShapeDrawingProperties();
            ApplicationNonVisualDrawingProperties applicationNonVisualDrawingProperties1 = new ApplicationNonVisualDrawingProperties();

            nonVisualGroupShapeProperties1.Append(nonVisualDrawingProperties1);
            nonVisualGroupShapeProperties1.Append(nonVisualGroupShapeDrawingProperties1);
            nonVisualGroupShapeProperties1.Append(applicationNonVisualDrawingProperties1);

            GroupShapeProperties groupShapeProperties1 = new GroupShapeProperties();

            D.TransformGroup transformGroup1 = new D.TransformGroup();
            D.Offset offset1 = new D.Offset() { X = left, Y = top };
            D.Extents extents1 = new D.Extents() { Cx = width, Cy = height };
            D.ChildOffset childOffset1 = new D.ChildOffset() { X = 0L, Y = 0L };
            D.ChildExtents childExtents1 = new D.ChildExtents() { Cx = width, Cy = height };

            transformGroup1.Append(offset1);
            transformGroup1.Append(extents1);
            transformGroup1.Append(childOffset1);
            transformGroup1.Append(childExtents1);

            groupShapeProperties1.Append(transformGroup1);

            groupShape1.Append(nonVisualGroupShapeProperties1);
            groupShape1.Append(groupShapeProperties1);
            var errors = validator.Validate(groupShape1);
            if (errors.Count() > 0) throw new ApplicationException("Invalid Xml presentation generated by CreateGroupShape.");
            return groupShape1;
        }

        /// <summary>
        /// Add a connector between two shapes. A connector is a line which links two shapes.
        /// If one of the two shapes is moved, the corresponding line end follows.
        /// A line end is linked to a particular point of each shape.
        /// According to this implementation, the link points are the ones of index 1.
        /// </summary>
        /// <param name="startShape">First shape. he order is useful if you plan to put an arrow on the connetor.</param>
        /// <param name="endShape">Second shape.</param>
        /// <param name="startPoint">Begin [x,y] point of the segment. Only change the first position of the line.
        /// On first shape moved or Powerpoint's connector reaclculation, it joins to the linked point.</param>
        /// <param name="endPoint">End [x,y] point of the segment. Purely esthetic.</param>
        /// <returns>The new connector.</returns>
        public static ConnectionShape CreateConnectionShape(Shape startShape, Shape endShape, int[] startPoint, int[] endPoint) {
            if (startPoint.Length != 2) throw new ArgumentException("startPoint should be an array of length 2.", "startPoint");
            if (endPoint.Length != 2) throw new ArgumentException("endPoint should be an array of length 2.", "endPoint");
            
            D.StartConnection startConnection = new D.StartConnection() { Id = startShape.NonVisualShapeProperties.NonVisualDrawingProperties.Id, Index = 1 };
            D.EndConnection endConnection = new D.EndConnection() { Id = endShape.NonVisualShapeProperties.NonVisualDrawingProperties.Id, Index = 1 };

            //XOR (exclusive or): Purely esthetic: revert the line if start and end points are inverts. Forgotten on first recalculation.
            bool verticalFlip = (endPoint[0] > startPoint[0]) ^ (endPoint[1] > startPoint[1]);
            ConnectionShape connectionShape1 = new ConnectionShape();

            uint id = GetNextId();
            string typeName = "Connector";
            NonVisualConnectionShapeProperties nonVisualConnectionShapeProperties1 = new NonVisualConnectionShapeProperties();
            NonVisualDrawingProperties nonVisualDrawingProperties1 = new NonVisualDrawingProperties() { Id = (UInt32)id, Name = typeName + id };

            NonVisualConnectorShapeDrawingProperties nonVisualConnectorShapeDrawingProperties1 = new NonVisualConnectorShapeDrawingProperties();

            nonVisualConnectorShapeDrawingProperties1.Append(startConnection);
            nonVisualConnectorShapeDrawingProperties1.Append(endConnection);
            ApplicationNonVisualDrawingProperties applicationNonVisualDrawingProperties1 = new ApplicationNonVisualDrawingProperties();

            nonVisualConnectionShapeProperties1.Append(nonVisualDrawingProperties1);
            nonVisualConnectionShapeProperties1.Append(nonVisualConnectorShapeDrawingProperties1);
            nonVisualConnectionShapeProperties1.Append(applicationNonVisualDrawingProperties1);

            ShapeProperties shapeProperties1 = new ShapeProperties();

            D.Transform2D transform2D1 = new D.Transform2D() { VerticalFlip = verticalFlip };
            D.Offset offset1 = new D.Offset() { X = Math.Min(startPoint[0], endPoint[0]), Y = Math.Min(startPoint[1], endPoint[1]) };
            D.Extents extents1 = new D.Extents() { Cx = Math.Abs(endPoint[0] - startPoint[0]), Cy = Math.Abs(endPoint[1] - startPoint[1]) };

            transform2D1.Append(offset1);
            transform2D1.Append(extents1);

            D.PresetGeometry presetGeometry1 = new D.PresetGeometry() { Preset = D.ShapeTypeValues.StraightConnector1 };
            D.AdjustValueList adjustValueList1 = new D.AdjustValueList();

            presetGeometry1.Append(adjustValueList1);

            D.Outline outline1 = new D.Outline();

            D.SolidFill solidFill1 = new D.SolidFill();
            D.RgbColorModelHex rgbColorModelHex1 = new D.RgbColorModelHex() { Val = "212121" };

            solidFill1.Append(rgbColorModelHex1);

            outline1.Append(solidFill1);

            shapeProperties1.Append(transform2D1);
            shapeProperties1.Append(presetGeometry1);
            shapeProperties1.Append(outline1);


            connectionShape1.Append(nonVisualConnectionShapeProperties1);
            connectionShape1.Append(shapeProperties1);

            var errors = validator.Validate(connectionShape1);
            if (errors.Count() > 0) throw new ApplicationException("Invalid Xml presentation generated by CreateConnectionShape.");
            return connectionShape1;
        }

        /// <summary>
        /// Resize the given groupShape.
        /// Its content is adjusted and can be distorded according to the new size.
        /// </summary>
        /// <param name="groupShape">The groupShape to resize.</param>
        /// <param name="width">New width of the group shape in EMU. It should be positive.</param>
        /// <param name="height">New height of the group shape in EMU. It should be positive.</param>
        public static void ResizeGroup(GroupShape groupShape, int width, int height) {
            if (width < 0) throw new ArgumentOutOfRangeException("width", width, "width should be positive.");
            if (height < 0) throw new ArgumentOutOfRangeException("height", height, "height should be positive.");
            
            groupShape.GroupShapeProperties.TransformGroup.Extents = new D.Extents() { Cx = width, Cy = height };
            var errors = validator.Validate(groupShape);
            if (errors.Count() > 0) throw new ApplicationException("Invalid Xml presentation generated by ResizeGroup.");
        }

        /// <summary>
        /// Get the first slide part. The slide part is between the presentation and the slide in Xml tree.
        /// Currently this funtion is only called by GetShapeTreeOfFirstSlide().
        /// </summary>
        /// <param name="presentationDocument">Presentation containing the wanted slide part.</param>
        /// <returns>The first slide part.</returns>
        private static SlidePart GetFirstSlidePart(PresentationDocument presentationDocument) {
            OpenXmlElementList slideIds = presentationDocument.PresentationPart.Presentation.SlideIdList.ChildElements;
            string relId = (slideIds[0] as SlideId).RelationshipId;
            SlidePart slidePart = (SlidePart)presentationDocument.PresentationPart.GetPartById(relId);
            return slidePart;
        }

        /// <summary>
        /// Create mandatory parts of a presentation and add them to presentationPart.
        /// Also create and add a slide of the given size.
        /// </summary>
        /// <param name="presentationPart">The presentationPart getting its mandatory parts.</param>
        /// <param name="slideWidth">The width of the new slide.</param>
        /// <param name="slideHeight">The height of the new slide.</param>
        private static void CreatePresentationParts(PresentationPart presentationPart, int slideWidth, int slideHeight) {
            if (slideWidth < 914440) throw new ArgumentOutOfRangeException("slideWidth", slideWidth, "slideWidth should be greater than 914440.");
            if (slideHeight < 914440) throw new ArgumentOutOfRangeException("slideHeight", slideHeight, "slideHeight should be greater than 914440.");

            SlideMasterIdList slideMasterIdList1 = new SlideMasterIdList(new SlideMasterId() { Id = (UInt32Value)2147483648U, RelationshipId = "rId1" });
            SlideIdList slideIdList1 = new SlideIdList(new SlideId() { Id = (UInt32Value)256U, RelationshipId = "rId2" });
            SlideSize slideSize1 = new SlideSize() { Cx = slideWidth, Cy = slideHeight };
            NotesSize notesSize1 = new NotesSize() { Cx = slideHeight, Cy = slideWidth };
            DefaultTextStyle defaultTextStyle1 = new DefaultTextStyle();

            presentationPart.Presentation.Append(slideMasterIdList1, slideIdList1, slideSize1, notesSize1, defaultTextStyle1);

            SlidePart slidePart1;
            SlideLayoutPart slideLayoutPart1;
            SlideMasterPart slideMasterPart1;
            ThemePart themePart1;

            slidePart1 = CreateSlidePart(presentationPart);
            slideLayoutPart1 = CreateSlideLayoutPart(slidePart1);
            slideMasterPart1 = CreateSlideMasterPart(slideLayoutPart1);
            themePart1 = CreateTheme(slideMasterPart1);

            slideMasterPart1.AddPart(slideLayoutPart1, "rId1");
            presentationPart.AddPart(slideMasterPart1, "rId1");
            presentationPart.AddPart(themePart1, "rId5");

            var errors = validator.Validate(presentationPart);
            if (errors.Count() > 0) throw new ApplicationException("Invalid Xml presentation generated by CreatePresentationParts.");
        }

        /// <summary>
        /// Create and add a slidePart to the given presentationPart.
        /// Also create and add a slide to this new slidePart.
        /// </summary>
        /// <param name="presentationPart">The presentationPart getting the slidePart.</param>
        /// <returns>The new slidePart.</returns>
        private static SlidePart CreateSlidePart(PresentationPart presentationPart) {
            SlidePart slidePart1 = presentationPart.AddNewPart<SlidePart>("rId2");
            slidePart1.Slide = new Slide(
                    new CommonSlideData(
                        new ShapeTree(
                            new NonVisualGroupShapeProperties(
                                new NonVisualDrawingProperties() { Id = (UInt32Value)1U, Name = "" },
                                new NonVisualGroupShapeDrawingProperties(),
                                new ApplicationNonVisualDrawingProperties()),
                            new GroupShapeProperties(new D.TransformGroup()))),
                    new ColorMapOverride(new D.MasterColorMapping()));

            var errors = validator.Validate(slidePart1);
            if (errors.Count() > 0) throw new ApplicationException("Invalid Xml presentation generated by CreateSlidePart.");
            return slidePart1;
        }

        /// <summary>
        /// Create and add a slideLayoutPart to the given SlidePart.
        /// </summary>
        /// <param name="slidePart1">The SlidePart getting the slideLayoutPart.</param>
        /// <returns>The new slideLayoutPart.</returns>
        private static SlideLayoutPart CreateSlideLayoutPart(SlidePart slidePart1) {
            SlideLayoutPart slideLayoutPart1 = slidePart1.AddNewPart<SlideLayoutPart>("rId1");
            SlideLayout slideLayout = new SlideLayout(
            new CommonSlideData(new ShapeTree(
              new NonVisualGroupShapeProperties(
              new NonVisualDrawingProperties() { Id = (UInt32Value)1U, Name = "" },
              new NonVisualGroupShapeDrawingProperties(),
              new ApplicationNonVisualDrawingProperties()),
              new GroupShapeProperties(new D.TransformGroup()),
              new Shape(
              new NonVisualShapeProperties(
                new NonVisualDrawingProperties() { Id = (UInt32Value)2U, Name = "" },
                new NonVisualShapeDrawingProperties(new D.ShapeLocks() { NoGrouping = true }),
                new ApplicationNonVisualDrawingProperties(new PlaceholderShape())),
              new ShapeProperties(),
              new TextBody(
                new D.BodyProperties(),
                new D.ListStyle(),
                new D.Paragraph(new D.EndParagraphRunProperties()))))),
            new ColorMapOverride(new D.MasterColorMapping()));
            slideLayoutPart1.SlideLayout = slideLayout;

            var errors = validator.Validate(slideLayoutPart1);
            if (errors.Count() > 0) throw new ApplicationException("Invalid Xml presentation generated by CreateSlideLayoutPart.");
            return slideLayoutPart1;
        }

        /// <summary>
        /// Create and add a SlideMasterPart to the given slideLayoutPart.
        /// </summary>
        /// <param name="slideLayoutPart1">The slideLayoutPart getting the SlideMasterPart.</param>
        /// <returns>The new SlideMasterPart.</returns>
        private static SlideMasterPart CreateSlideMasterPart(SlideLayoutPart slideLayoutPart1) {
            SlideMasterPart slideMasterPart1 = slideLayoutPart1.AddNewPart<SlideMasterPart>("rId1");
            SlideMaster slideMaster = new SlideMaster(
            new CommonSlideData(new ShapeTree(
              new NonVisualGroupShapeProperties(
              new NonVisualDrawingProperties() { Id = (UInt32Value)1U, Name = "" },
              new NonVisualGroupShapeDrawingProperties(),
              new ApplicationNonVisualDrawingProperties()),
              new GroupShapeProperties(new D.TransformGroup()),
              new Shape(
              new NonVisualShapeProperties(
                new NonVisualDrawingProperties() { Id = (UInt32Value)2U, Name = "Title Placeholder 1" },
                new NonVisualShapeDrawingProperties(new D.ShapeLocks() { NoGrouping = true }),
                new ApplicationNonVisualDrawingProperties(new PlaceholderShape() { Type = PlaceholderValues.Title })),
              new ShapeProperties(),
              new TextBody(
                new D.BodyProperties(),
                new D.ListStyle(),
                new D.Paragraph())))),
            new ColorMap() { Background1 = D.ColorSchemeIndexValues.Light1, Text1 = D.ColorSchemeIndexValues.Dark1, Background2 = D.ColorSchemeIndexValues.Light2, Text2 = D.ColorSchemeIndexValues.Dark2, Accent1 = D.ColorSchemeIndexValues.Accent1, Accent2 = D.ColorSchemeIndexValues.Accent2, Accent3 = D.ColorSchemeIndexValues.Accent3, Accent4 = D.ColorSchemeIndexValues.Accent4, Accent5 = D.ColorSchemeIndexValues.Accent5, Accent6 = D.ColorSchemeIndexValues.Accent6, Hyperlink = D.ColorSchemeIndexValues.Hyperlink, FollowedHyperlink = D.ColorSchemeIndexValues.FollowedHyperlink },
            new SlideLayoutIdList(new SlideLayoutId() { Id = (UInt32Value)2147483649U, RelationshipId = "rId1" }),
            new TextStyles(new TitleStyle(), new BodyStyle(), new OtherStyle()));
            slideMasterPart1.SlideMaster = slideMaster;

            //Can't test slideMasterPart1 validity here as it is invalid on its own.
            return slideMasterPart1;
        }

        /// <summary>
        /// Create and add a ThemePart to the given SlideMasterPart.
        /// </summary>
        /// <param name="slideMasterPart1">The SlideMasterPart getting the ThemePart.</param>
        /// <returns>The new ThemePart.</returns>
        private static ThemePart CreateTheme(SlideMasterPart slideMasterPart1) {
            ThemePart themePart1 = slideMasterPart1.AddNewPart<ThemePart>("rId5");
            D.Theme theme1 = new D.Theme() { Name = "Office Theme" };

            D.ThemeElements themeElements1 = new D.ThemeElements(
            new D.ColorScheme(
              new D.Dark1Color(new D.SystemColor() { Val = D.SystemColorValues.WindowText, LastColor = "000000" }),
              new D.Light1Color(new D.SystemColor() { Val = D.SystemColorValues.Window, LastColor = "FFFFFF" }),
              new D.Dark2Color(new D.RgbColorModelHex() { Val = "1F497D" }),
              new D.Light2Color(new D.RgbColorModelHex() { Val = "EEECE1" }),
              new D.Accent1Color(new D.RgbColorModelHex() { Val = "4F81BD" }),
              new D.Accent2Color(new D.RgbColorModelHex() { Val = "C0504D" }),
              new D.Accent3Color(new D.RgbColorModelHex() { Val = "9BBB59" }),
              new D.Accent4Color(new D.RgbColorModelHex() { Val = "8064A2" }),
              new D.Accent5Color(new D.RgbColorModelHex() { Val = "4BACC6" }),
              new D.Accent6Color(new D.RgbColorModelHex() { Val = "F79646" }),
              new D.Hyperlink(new D.RgbColorModelHex() { Val = "0000FF" }),
              new D.FollowedHyperlinkColor(new D.RgbColorModelHex() { Val = "800080" })) { Name = "Office" },
              new D.FontScheme(
              new D.MajorFont(
              new D.LatinFont() { Typeface = "Calibri" },
              new D.EastAsianFont() { Typeface = "" },
              new D.ComplexScriptFont() { Typeface = "" }),
              new D.MinorFont(
              new D.LatinFont() { Typeface = "Calibri" },
              new D.EastAsianFont() { Typeface = "" },
              new D.ComplexScriptFont() { Typeface = "" })) { Name = "Office" },
              new D.FormatScheme(
              new D.FillStyleList(
              new D.SolidFill(new D.SchemeColor() { Val = D.SchemeColorValues.PhColor }),
              new D.GradientFill(
                new D.GradientStopList(
                new D.GradientStop(new D.SchemeColor(new D.Tint() { Val = 50000 },
                  new D.SaturationModulation() { Val = 300000 }) { Val = D.SchemeColorValues.PhColor }) { Position = 0 },
                new D.GradientStop(new D.SchemeColor(new D.Tint() { Val = 37000 },
                 new D.SaturationModulation() { Val = 300000 }) { Val = D.SchemeColorValues.PhColor }) { Position = 35000 },
                new D.GradientStop(new D.SchemeColor(new D.Tint() { Val = 15000 },
                 new D.SaturationModulation() { Val = 350000 }) { Val = D.SchemeColorValues.PhColor }) { Position = 100000 }
                ),
                new D.LinearGradientFill() { Angle = 16200000, Scaled = true }),
              new D.NoFill(),
              new D.PatternFill(),
              new D.GroupFill()),
              new D.LineStyleList(
              new D.Outline(
                new D.SolidFill(
                new D.SchemeColor(
                  new D.Shade() { Val = 95000 },
                  new D.SaturationModulation() { Val = 105000 }) { Val = D.SchemeColorValues.PhColor }),
                new D.PresetDash() { Val = D.PresetLineDashValues.Solid }) {
                    Width = 9525,
                    CapType = D.LineCapValues.Flat,
                    CompoundLineType = D.CompoundLineValues.Single,
                    Alignment = D.PenAlignmentValues.Center
                },
              new D.Outline(
                new D.SolidFill(
                new D.SchemeColor(
                  new D.Shade() { Val = 95000 },
                  new D.SaturationModulation() { Val = 105000 }) { Val = D.SchemeColorValues.PhColor }),
                new D.PresetDash() { Val = D.PresetLineDashValues.Solid }) {
                    Width = 9525,
                    CapType = D.LineCapValues.Flat,
                    CompoundLineType = D.CompoundLineValues.Single,
                    Alignment = D.PenAlignmentValues.Center
                },
              new D.Outline(
                new D.SolidFill(
                new D.SchemeColor(
                  new D.Shade() { Val = 95000 },
                  new D.SaturationModulation() { Val = 105000 }) { Val = D.SchemeColorValues.PhColor }),
                new D.PresetDash() { Val = D.PresetLineDashValues.Solid }) {
                    Width = 9525,
                    CapType = D.LineCapValues.Flat,
                    CompoundLineType = D.CompoundLineValues.Single,
                    Alignment = D.PenAlignmentValues.Center
                }),
              new D.EffectStyleList(
              new D.EffectStyle(
                new D.EffectList(
                new D.OuterShadow(
                  new D.RgbColorModelHex(
                  new D.Alpha() { Val = 38000 }) { Val = "000000" }) { BlurRadius = 40000L, Distance = 20000L, Direction = 5400000, RotateWithShape = false })),
              new D.EffectStyle(
                new D.EffectList(
                new D.OuterShadow(
                  new D.RgbColorModelHex(
                  new D.Alpha() { Val = 38000 }) { Val = "000000" }) { BlurRadius = 40000L, Distance = 20000L, Direction = 5400000, RotateWithShape = false })),
              new D.EffectStyle(
                new D.EffectList(
                new D.OuterShadow(
                  new D.RgbColorModelHex(
                  new D.Alpha() { Val = 38000 }) { Val = "000000" }) { BlurRadius = 40000L, Distance = 20000L, Direction = 5400000, RotateWithShape = false }))),
              new D.BackgroundFillStyleList(
              new D.SolidFill(new D.SchemeColor() { Val = D.SchemeColorValues.PhColor }),
              new D.GradientFill(
                new D.GradientStopList(
                new D.GradientStop(
                  new D.SchemeColor(new D.Tint() { Val = 50000 },
                    new D.SaturationModulation() { Val = 300000 }) { Val = D.SchemeColorValues.PhColor }) { Position = 0 },
                new D.GradientStop(
                  new D.SchemeColor(new D.Tint() { Val = 50000 },
                    new D.SaturationModulation() { Val = 300000 }) { Val = D.SchemeColorValues.PhColor }) { Position = 0 },
                new D.GradientStop(
                  new D.SchemeColor(new D.Tint() { Val = 50000 },
                    new D.SaturationModulation() { Val = 300000 }) { Val = D.SchemeColorValues.PhColor }) { Position = 0 }),
                new D.LinearGradientFill() { Angle = 16200000, Scaled = true }),
              new D.GradientFill(
                new D.GradientStopList(
                new D.GradientStop(
                  new D.SchemeColor(new D.Tint() { Val = 50000 },
                    new D.SaturationModulation() { Val = 300000 }) { Val = D.SchemeColorValues.PhColor }) { Position = 0 },
                new D.GradientStop(
                  new D.SchemeColor(new D.Tint() { Val = 50000 },
                    new D.SaturationModulation() { Val = 300000 }) { Val = D.SchemeColorValues.PhColor }) { Position = 0 }),
                new D.LinearGradientFill() { Angle = 16200000, Scaled = true }))) { Name = "Office" });

            theme1.Append(themeElements1);
            theme1.Append(new D.ObjectDefaults());
            theme1.Append(new D.ExtraColorSchemeList());

            themePart1.Theme = theme1;

            var errors = validator.Validate(themePart1);
            if (errors.Count() > 0) throw new ApplicationException("Invalid Xml presentation generated by CreateTheme.");
            return themePart1;

        }

        /// <summary>
        /// Create a NonVisualShapeProperties with its mandatory parts and default values.
        /// A NonVisualShapeProperties is a mandatory par of a shape.
        /// </summary>
        /// <param name="id">Id to give to the shape.</param>
        /// <param name="typeName">Name to give to the shape.</param>
        /// <returns>The new NonVisualShapeProperties.</returns>
        private static NonVisualShapeProperties CreateNonVisualShapeProperties(uint id, string typeName) {

            NonVisualShapeProperties nonVisualShapeProperties1 = new NonVisualShapeProperties();
            NonVisualDrawingProperties nonVisualDrawingProperties1 = new NonVisualDrawingProperties() { Id = id, Name = typeName + id };
            NonVisualShapeDrawingProperties nonVisualShapeDrawingProperties1 = new NonVisualShapeDrawingProperties();
            ApplicationNonVisualDrawingProperties applicationNonVisualDrawingProperties1 = new ApplicationNonVisualDrawingProperties();

            nonVisualShapeProperties1.Append(nonVisualDrawingProperties1);
            nonVisualShapeProperties1.Append(nonVisualShapeDrawingProperties1);
            nonVisualShapeProperties1.Append(applicationNonVisualDrawingProperties1);

            var errors = validator.Validate(nonVisualShapeProperties1);
            if (errors.Count() > 0) throw new ApplicationException("Invalid Xml presentation generated by CreateNonVisualShapeProperties.");
            return nonVisualShapeProperties1;
        }

        /// <summary>
        /// Get the fourth extremum values of a coordinate list: xmin, xmax, ymin, ymax.
        /// </summary>
        /// <param name="list">The list of [x,y] points.</param>
        /// <returns>[xMin, xMax, yMin, yMax]</returns>
        private static int[] GetExtremumCoordinate(List<int[]> list) {
            foreach (int[] point in list) {
                if (point.Length != 2) throw new ArgumentException("list should be a list of array of length 2.", "list");
            }

            int xMin = list.Min(c => c[0]);
            int xMax = list.Max(c => c[0]);
            int yMin = list.Min(c => c[1]);
            int yMax = list.Max(c => c[1]);
            return new int[] { xMin, xMax, yMin, yMax };
        }

        /// <summary>
        /// Check if the given code is a correct hexadecimal color code and throw ArgumentException otherwise.
        /// It can be null or of the format: RRGGBB.
        /// </summary>
        /// <param name="colorCode">The code to test.</param>
        private static void CheckHexaColorCode(string colorCode) {
            if (colorCode != null && !hexaColorRegex.IsMatch(colorCode)) throw new ArgumentException("The given color code should be a string of 6 hexadecimal digit.");
        }
    }
}